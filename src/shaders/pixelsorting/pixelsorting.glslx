precision lowp int;
precision lowp float;

uniform vec4 filterArea;
uniform vec2 iResolution;
uniform vec2 size;
varying vec2 vTextureCoord;
uniform vec2 variable;
uniform sampler2D uSampler;

float THRESHOLD1 =.0;
float THRESHOLD2= 1.0;

vec4 colorarray[10];
















vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}
























vec2 mapCoord( vec2 coord )
{
    coord *= filterArea.xy;
    coord += filterArea.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= filterArea.zw;
    coord /= filterArea.xy;

    return coord;
}

float levelChannel(float inPixel, float inBlack, float inGamma, float inWhite, float outBlack, float outWhite) {
    return (pow(((inPixel * 255.0) - inBlack) / (inWhite - inBlack), inGamma) * (outWhite - outBlack) + outBlack) / 255.0;
}

vec3 levels(vec3 inPixel, float inBlack, float inGamma, float inWhite, float outBlack, float outWhite) {
    vec3 o = vec3(1.0);
    o.r = levelChannel(inPixel.r, inBlack, inGamma, inWhite, outBlack, outWhite);
    o.g = levelChannel(inPixel.g, inBlack, inGamma, inWhite, outBlack, outWhite);
    o.b = levelChannel(inPixel.b, inBlack, inGamma, inWhite, outBlack, outWhite);
    return o;
}

//"Random" function borrowed from The Book of Shaders: Random
float random ( vec2 xy )
{
    return fract( sin( dot( xy.xy, vec2(12, 78) ) ) );
}

float luminance(vec4 color)
{
    return ( (color.r * 0.3) + (color.g * 0.6) + (color.b * 0.1) ) * color.a;
}

vec4 preProcessTexture(vec2 coords) {
    vec3 prepareTexture = levels(texture2D( uSampler, coords ).xyz, 75.0, 1.0, 200.0, 0.0, 255.0);
    float gray = dot(prepareTexture.rgb, vec3(0.299, 0.587, 0.114));
    return vec4(vec3(gray), 1.0);
}

// Returns the y coordinate of the first pixel that is brighter than the threshold
float getFirstThresholdPixel(vec4 texture, vec2 xy, float threshold)
{
	float luma ;
    float initialY = xy.y;
	//Looking at every sequential pixel is very resource intensive,
	//thus, we'll increment the inspected pixel by dividing the image height in sections,
	//and add a little randomness across the x axis to hide the division of said sections
    float increment = 1.0;//iResolution.y / (10.0 + (random( xy.xx ) * 6.0)); 
    //Check if the luminance of the current pixel is brighter than the threshold,
    //if not, check the next pixel
	for( int i = 699; i >=0; --i )
	{
        if( xy.y <= 0.0 ) break;
		luma = luminance( preProcessTexture(unmapCoord(xy)) );
        if(luma > threshold) break;
        else xy.y -= increment;
	}
    if(xy.y <= 0.0) xy.y = initialY;
	return xy.y;
}

/*float getFirstThresholdPixel(vec2 xy, float threshold)
{
   
    vec2 movedTextureCoord;
    vec4 testColor;
    float luma;
    vec4 lumcoeff = vec4(vec3( 0.299, 0.587, 0.114 ),0.0);
    float translate = 0.0;
	for(int i=600; i > 0; i--){
        translate = translate + 1.0;
		vec2 translation = vec2(0, translate);
        movedTextureCoord = xy - translation;

        testColor = texture2D(uSampler, unmapCoord(movedTextureCoord));
        luma = dot(testColor, lumcoeff);
        if(luma > threshold){
            return xy.y - translate;
            break;
        }
	}
    return 0.0;
}*/

//Puts 10 pixels in an array
void putItIn( vec2 startxy, float size )
{
    vec2 xy;
    
    for( int j = 9; j >= 0; --j )
    {
        //Divide the line of pixels into 10 sections,
        //then store the pixel found at the junction of each section
        xy = vec2(startxy.x, startxy.y + (size / 9.0) * float(j));
        colorarray[j] = texture2D( uSampler, unmapCoord(xy) );
    }
    
}

//An attempt at Bubble sort for 10 pixels, sorting them from darkest to brightest, top to bottom
void sortArray()
{
    vec4 tempcolor;
    int swapped = 1;
    for( int m = 1; m > 0; --m )
    {
        if(swapped==0)break;
        swapped = 0;
        for( int j = 9; j >= 0; --j )
        {
            if( luminance(colorarray[j]) > luminance(colorarray[j - 1]) )
            {           
                tempcolor = colorarray[j];
                colorarray[j] = colorarray[j - 1];
                colorarray[j - 1] = tempcolor;
            
                ++swapped;
            }
        }
    }
    
}

vec4 getValueInColorArray(int index) {
    if (index == 0) {
        return colorarray[0];
    } else if (index == 1) {
        return colorarray[1];
    } else if (index == 2) {
       return colorarray[2];
    } else if (index == 3) {
        return colorarray[3];
    } else if (index == 4) {
       return colorarray[4];
    } else if (index == 5) {
        return colorarray[5];
    } else if (index == 6) {
       return colorarray[6];
    } else if (index == 7) {
        return colorarray[7];
    } else if (index == 8) {
       return colorarray[8];
    } else if (index == 9) {
        return colorarray[9];
    }
    return colorarray[0];
}

void initColorArray() {
    for( int j = 0; j < 10; j++ )
    {
        colorarray[j] = vec4(1.0);
    }
}

float getPseudoRandomDistance(float coordX) {
    //return random(vec2(coordX,0)) * (size.x * 100.) + (size.x * 500.);
    //return snoise(vec2(coordX,0)) * (size.x * 100.) + (size.x * 500.);
    return sin(coordX / 10.) * sin(coordX) * (size.x * 100.) + (size.x * 500.);
}

void main(void)
{ 
    THRESHOLD1 = 0.3;
    THRESHOLD2 = 1.0 - THRESHOLD1;
    initColorArray();
    
    vec4 gsTexture = preProcessTexture(vTextureCoord);
    vec2 coord = mapCoord(vTextureCoord);
	float firsty = getFirstThresholdPixel( gsTexture, vec2(coord.x, iResolution.y), THRESHOLD2 );
    //float secondy = getFirstThresholdPixel( gsTexture, vec2(coord.x, firsty), THRESHOLD2 );
    float secondy = firsty - getPseudoRandomDistance(coord.x);
   
    if(firsty < iResolution.y - 5.0 && coord.y < firsty && coord.y > secondy)
    {
        float distance = firsty - secondy;

		putItIn( vec2(coord.x, secondy), distance );
		sortArray( );
	
		float sectionSize = distance / 9.0;
		float location = floor( (coord.y - secondy) / sectionSize );
		float bottom = secondy + (sectionSize * location);
		float locationBetween = (coord.y - bottom) / sectionSize;

        //A simple method for "fading" between the colors of our ten sampled pixels
		vec4 topColor = getValueInColorArray(int(location) + 1) * locationBetween;
		vec4 bottomColor = getValueInColorArray(int(location)) * (1.0 - locationBetween);
		
		gl_FragColor = topColor + bottomColor;
        //gl_FragColor = vec4(1.0,0.6,0.0,1.0);
    } else {
        gl_FragColor = texture2D( uSampler, vTextureCoord );//gsTexture;
    }
    /*if( coord.y < firsty && coord.y > secondy){
        gl_FragColor = texture2D( uSampler, vTextureCoord ) + vec4(0.0,0.0,1.0,1.0);
    }else{
        gl_FragColor = gsTexture;
    }*/

    //Only work on the pixels that are between the two threshold pixels
    /*if( vTextureCoord.y < firsty && vTextureCoord.y > secondy )
    {
		float size = firsty - secondy;

		putItIn( vec2(vTextureCoord.x, secondy), size );
		sortArray( );
	
		float sectionSize = size / 9.0;
		float location = floor( (vTextureCoord.y - secondy) / sectionSize );
        int i = 5;
		float bottom = secondy + (sectionSize * location);
		float locationBetween = (vTextureCoord.y - bottom) / sectionSize;

        //A simple method for "fading" between the colors of our ten sampled pixels
		vec4 topColor = getValueInColorArray(int(location) + 1) * locationBetween;
		vec4 bottomColor = getValueInColorArray(int(location)) * (1.0 - locationBetween);
		
		gl_FragColor = vec4(1.0,0.0,0.0,1.0);//topColor + bottomColor;
    }
    else
    {
		gl_FragColor = texture2D( uSampler, vTextureCoord );
    }*/
}

