precision lowp int;

uniform vec4 filterArea;
uniform vec2 iResolution;
uniform vec2 size;
varying vec2 vTextureCoord;
uniform vec2 variable;
uniform sampler2D uSampler;

float THRESHOLD1 =.0;
float THRESHOLD2= 1.0;


vec4 colorarray[10];

vec2 mapCoord( vec2 coord )
{
    coord *= filterArea.xy;
    coord += filterArea.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= filterArea.zw;
    coord /= filterArea.xy;

    return coord;
}

//"Random" function borrowed from The Book of Shaders: Random
float random ( vec2 xy )
{
    return fract( sin( dot( xy.xy, vec2(12, 78) ) ) );
}

float luminance(vec4 color)
{
    return ( (color.r * 0.3) + (color.g * 0.6) + (color.b * 0.1) ) * color.a;
}

// Returns the y coordinate of the first pixel that is brighter than the threshold
float getFirstThresholdPixel(vec2 xy, float threshold)
{
	float luma ;

	//Looking at every sequential pixel is very resource intensive,
	//thus, we'll increment the inspected pixel by dividing the image height in sections,
	//and add a little randomness across the x axis to hide the division of said sections
    float increment = 1.0; 
    //Check if the luminance of the current pixel is brighter than the threshold,
    //if not, check the next pixel
	for( int i = 1000; i >=0; --i )
	{
		xy.y -= increment;
        if( xy.y <= 0.0 ) return 0.0;
		luma = luminance( texture2D( uSampler, unmapCoord(xy) ) );
        if(luma > threshold) break;
	}
    
	return xy.y;
}

/*float getFirstThresholdPixel(vec2 xy, float threshold)
{
   
    vec2 movedTextureCoord;
    vec4 testColor;
    float luma;
    vec4 lumcoeff = vec4(vec3( 0.299, 0.587, 0.114 ),0.0);
    float translate = 0.0;
	for(int i=600; i > 0; i--){
        translate = translate + 1.0;
		vec2 translation = vec2(0, translate);
        movedTextureCoord = xy - translation;

        testColor = texture2D(uSampler, unmapCoord(movedTextureCoord));
        luma = dot(testColor, lumcoeff);
        if(luma > threshold){
            return xy.y - translate;
            break;
        }
	}
    return 0.0;
}*/

//Puts 10 pixels in an array
void putItIn( vec2 startxy, float size )
{
    vec2 xy;
    
    for( int j = 9; j >= 0; --j )
    {
        //Divide the line of pixels into 10 sections,
        //then store the pixel found at the junction of each section
        xy = vec2(startxy.x, startxy.y + (size / 9.0) * float(j));
        
        colorarray[j] = texture2D( uSampler, unmapCoord(xy) );
    }
    
}

//An attempt at Bubble sort for 10 pixels, sorting them from darkest to brightest, top to bottom
void sortArray()
{
    vec4 tempcolor;
    int swapped = 1;
    
    for( int j = 9; j > 0; --j )
    {
    	if( luminance(colorarray[j]) > luminance(colorarray[j - 1]) )
    	{           
        	tempcolor = colorarray[j];
        	colorarray[j] = colorarray[j - 1];
        	colorarray[j - 1] = tempcolor;
        
        	++swapped;
    	}
    }
    
}

vec4 getValueInColorArray(int index) {
    if (index == 0) {
        return colorarray[0];
    } else if (index == 1) {
        return colorarray[1];
    } else if (index == 2) {
       return colorarray[2];
    } else if (index == 3) {
        return colorarray[3];
    } else if (index == 4) {
       return colorarray[4];
    } else if (index == 5) {
        return colorarray[5];
    } else if (index == 6) {
       return colorarray[6];
    } else if (index == 7) {
        return colorarray[7];
    } else if (index == 8) {
       return colorarray[8];
    } else if (index == 9) {
        return colorarray[9];
    }
    return colorarray[0];
}


void setValueInColorArray(int index, vec4 value) {
    if (index == 0) {
        colorarray[0] = value;
    } else if (index == 1) {
        colorarray[1] = value;
    } else if (index == 2) {
       colorarray[2] = value;
    } else if (index == 3) {
        colorarray[3] = value;
    } else if (index == 4) {
       colorarray[4] = value;
    } else if (index == 5) {
        colorarray[5] = value;
    } else if (index == 6) {
       colorarray[6] = value;
    } else if (index == 7) {
        colorarray[7] = value;
    } else if (index == 8) {
       colorarray[8] = value;
    } else if (index == 9) {
        colorarray[9] = value;
    }
}

void main(void)
{ 
    THRESHOLD1 = size.x / iResolution.x;
    THRESHOLD2 = 1. - THRESHOLD1;

    vec2 coord = mapCoord(vTextureCoord);
	float firsty = getFirstThresholdPixel( vec2(coord.x, iResolution.y), THRESHOLD1 );
    float secondy = getFirstThresholdPixel( vec2(coord.x, firsty) - 1.0, THRESHOLD2 );
   
    if( coord.y < firsty && coord.y > secondy)
    {
        float size = firsty - secondy;

		putItIn( vec2(coord.x, secondy), size );
		sortArray( );
	
		float sectionSize = size / 9.0;
		float location = floor( (coord.y - secondy) / sectionSize );
        int i = 5;
		float bottom = secondy + (sectionSize * location);
		float locationBetween = (coord.y - bottom) / sectionSize;

        //A simple method for "fading" between the colors of our ten sampled pixels
		vec4 topColor = getValueInColorArray(int(location) + 1) * locationBetween;
		vec4 bottomColor = getValueInColorArray(int(location)) * (1.0 - locationBetween);
		
		gl_FragColor = topColor + bottomColor;
        //gl_FragColor = vec4(1.0,0.6,0.0,1.0);
    } else {
        gl_FragColor = texture2D( uSampler, vTextureCoord );
    }

    //Only work on the pixels that are between the two threshold pixels
    /*if( vTextureCoord.y < firsty && vTextureCoord.y > secondy )
    {
		float size = firsty - secondy;

		putItIn( vec2(vTextureCoord.x, secondy), size );
		sortArray( );
	
		float sectionSize = size / 9.0;
		float location = floor( (vTextureCoord.y - secondy) / sectionSize );
        int i = 5;
		float bottom = secondy + (sectionSize * location);
		float locationBetween = (vTextureCoord.y - bottom) / sectionSize;

        //A simple method for "fading" between the colors of our ten sampled pixels
		vec4 topColor = getValueInColorArray(int(location) + 1) * locationBetween;
		vec4 bottomColor = getValueInColorArray(int(location)) * (1.0 - locationBetween);
		
		gl_FragColor = vec4(1.0,0.0,0.0,1.0);//topColor + bottomColor;
    }
    else
    {
		gl_FragColor = texture2D( uSampler, vTextureCoord );
    }*/
}

